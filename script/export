#!/usr/bin/env node

const { figma } = require('../package.json')
const fs = require('fs-extra')
const path = require('path')
const SVGO = require('svgo')
const yaml = require('js-yaml')
const got = require('got')
const spinner = require('ora')("")

// Fail if there's no figma file key
let figmaFileKey;
try {
  figmaFileKey = figma.url.match(/file\/([a-z0-9]+)\//i)[1]
} catch (e) {
  console.error("Cannot find figma file key in package.json!", e)
  return process.exit(1)
}

spinner.info(`Exporting octicons from ${figma.url} file`)

// Where we're putting the exported SVG and data.json
// so the libraries can use it
const outputDir = path.resolve(__dirname, "../lib/build")

let dCount = 0
let oCount = 0
const progress = () => {
  let percentage = Math.ceil((dCount * 10) / oCount)
  let bar = [
    "[", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "]",
    ` ${Math.ceil((dCount * 100) / oCount)}%`
  ]
  for(let i = 1; i <= percentage; i++) {
    bar[i] = "="
  }
  return bar.join("")
}

const getFigmaComponents = () => {
  return new Promise((resolve, reject) => {
    spinner.info("Getting components from the figma file")
    spinner.start(`Contacting ${process.env.FIGMA_DOMAIN}`)
    got.get(`${process.env.FIGMA_DOMAIN}/v1/files/${figmaFileKey}`, {
      headers: { "Content-Type": "application/json", "x-figma-token": process.env.FIGMA_TOKEN },
      json: true
    })
    .then( response => {
      spinner.start(`Processing response`)
      let components = []
      const check = (c) => {
        if (c.type == "COMPONENT") {
          components.push(c)
        } else if (c.children) {
          c.children.forEach(check)
        }
      }
      response.body.document.children.forEach(check)
      return components
    })
    .then( components => {
      oCount = components.length
      spinner.succeed(`${components.length} icons found in the figma file`)
      return resolve(components)
    })
    .catch( err => {
      spinner.fail("Error: Getting getting octicons from figma file")
      reject(err)
    })
  })
}

const getFigmaImageUrls = (componentIds) => {
  spinner.info("Exporting figma components as SVG")
  return new Promise((resolve, reject) => {
    got.get(`${process.env.FIGMA_DOMAIN}/v1/images/${figmaFileKey}`, {
      query: {
        ids: componentIds,
        format: "svg"
      },
      headers: { "Content-Type": "application/json", "x-figma-token": process.env.FIGMA_TOKEN },
      json: true
    })
    .then( response => {
      if( response.body.err ) {
        reject(response.body.err)
      } else {
        spinner.succeed(`Successfully exported components`)
        resolve(response.body.images)
      }
    })
    .catch( err => reject(err) )
  })
}

const downloadSVG = (url, name) => {
  return new Promise(async (resolve, reject) => {
    const response = await got.get(url, {
      headers: { "Content-Type": "images/svg+xml" }
    }).on('downloadProgress', () => spinner.text = `${progress()} Downloading ${name} icon`)

    let svg = response.body
    // Translates a path based on the xy array passed in
    const translatePath = (p, xy) => {

      let ds = p.match(/([A-Z]{1,2}[\s0-9\.\-e]+)/g)
      let [x, y] = xy

      let dd = ds.map((d) => {
        var darr = d.split(" ").reverse()
        for(let i = 0; i < darr.length; i += 2) {
          if(darr[i+1]) {
            darr[i] = parseFloat(darr[i]) + y
            darr[i+1] = parseFloat(darr[i+1]) + x
          }
        }

        return darr.reverse().join(" ")
      }).join("") + "Z"

      return dd
    }

    // Gets the sum of all the `translate(x y)` and reduces it
    // <g transform="translate(-238 -286)"><g transform="translate(238 290)">
    // becomes [0, 4]
    const reduceTranslate = (t) => {
      if(t == null) {
        return [0, 0]
      }
      if(t.length == 1) {
        return t[0].replace(/translate|[\(\)]/g,"").split(" ").map((v) => Math.round(parseFloat(v)))
      }
      return t.reduce((p,c) => {
        p = p.replace(/translate|[\(\)]/g,"").split(" ")
        c = c.replace(/translate|[\(\)]/g,"").split(" ")
        for(let i = 0; i < c.length; i++) {
          c[i] = Math.round(parseFloat(p[i])) + Math.round(parseFloat(c[i]))
        }
        return c
      })
    }

    let d = svg.match(/ d=["']([a-z\s0-9\.\-]+)["']/i).pop()
    let translate = reduceTranslate(svg.match(/translate\([0-9\-\s\.e]+\)/g))
    let d2 = translatePath(d, translate)

    // Clean and replace svg elements
    svg = svg.replace(`d="${d}"`, `d="${d2}"`)
            .replace(/<\/?defs>/g,"")
            .replace(/<use[^>]*>/g, "")

    dCount++
    resolve(svg)
    // .catch(err => reject(`There was trouble downloading ${url}\n${err}`))
  })
}

// Clear the build directory
Promise.resolve(fs.removeSync(outputDir))

// Get the components
.then(() => getFigmaComponents())

// Construct a new data object
.then( components => {

  // returned data will be a new Object
  let data = {}

  // Map all components to a new object
  components.forEach((c) => {

    // Keywords extracted from description when that's ready
    let keywords = (c.description || "").match(/^keywords: (.+)$/mi)

    // If we have a match, get keywords and split by comma
    if(keywords) {
      keywords = keywords.pop().split(", ")
    } else {
      keywords = []
    }

    // Create a data object
    data[c.name] = {
      name: c.name,
      figma: {
        id: c.id,
        file: figmaFileKey
      },
      keywords: keywords,
      width: c.absoluteBoundingBox.width,
      height: c.absoluteBoundingBox.height,
    }
  })
  return data
})

.then( data => {

  // Make a query string with all the component ids
  let componentIds = Object.values(data).map((c) => c.figma.id ).join(",")

  // Request all the image export URLs from figma
  return getFigmaImageUrls(componentIds)
  .then(images => {

    let svgo = new SVGO(Object.assign(
      {},
      yaml.safeLoad(fs.readFileSync(path.resolve(__dirname,'../.svgo.yml'), 'utf8'))
    ))

    spinner.info("Downloading SVG files from aws")
    spinner.start("")
    // For each octicon
    return Promise.all(Object.values(data).map(icon => {

      // Request the svg data from aws
      return downloadSVG(images[icon.figma.id], icon.name)
        .then(svg => {
          return svgo.optimize(svg, {})
            .then(optimized => {
              icon.path = /<svg.+>(.+)<\/svg>/g.exec(optimized.data).pop()

              return fs.ensureDir(path.join(outputDir, "/svg"))
                .then(() => fs.writeFileSync(path.resolve(outputDir, `svg/${icon.name}.svg`), optimized.data, "utf8"))
            }).catch((err) => {
              console.error("Something went wrong optimizing the svg data!", err)
              process.exit(1)
            })
        })
    }))
  })
  .then(() => {
    return spinner.stopAndPersist({
      text: `${progress()} ${Object.keys(data).length} icons downloaded`
    })
  })
  .then(() => {
    spinner.info("Writing data out to lib/build/data.json")
    fs.writeFileSync(path.resolve(outputDir, `data.json`), JSON.stringify(data), "utf8")
  })
  .then(() => console.warn("\n  ðŸŽ‰ All done! Icons successfully exported."))
}).catch((err) => {
  console.error(err)
  process.exit(1)
})
