#!/usr/bin/env node
const PQueue = require('p-queue')
const SVGO = require('svgo')
const execa = require('execa')
const fs = require('fs-extra')
const got = require('got')
const spinner = require('ora')("")
const yaml = require('js-yaml')
const {join, resolve}  = require('path')

const {progress} = require('./utils.js')
const {figma} = require('../package.json')

// Fail if there's no figma file key
let figmaFileKey
try {
  figmaFileKey = figma.url.match(/file\/([a-z0-9]+)\//i)[1]
} catch (e) {
  console.error("Cannot find figma file key in package.json!", e)
  return process.exit(1)
}

const {
  FIGMA_DOMAIN = 'api.figma.com',
  FIGMA_TOKEN
} = process.env

// Where we're putting the exported SVG and data.json
// so the libraries can use it
const outputDir = resolve(__dirname, "../lib/build")

if (!FIGMA_TOKEN) {
  return getPreviousData()
    .catch(error => {
      console.error('nope:', error)
      process.exitCode = 1
    })
}

spinner.info(`Exporting octicons from ${figma.url} file`)

let dCount = 0
let oCount = 0

// Clear the build directory
fs.removeSync(outputDir)

// Get the components
getFigmaComponents()
  .then(components => {
    // Map all components to a new object
    return components.reduce((data, c) => {

      // Keywords extracted from description when that's ready
      let keywords = (c.description || "").match(/^keywords: (.+)$/mi)

      // If we have a match, get keywords and split by comma
      keywords = keywords ? keywords.pop().split(", ") : []

      // Create a data object
      data[c.name] = {
        name: c.name,
        figma: {
          id: c.id,
          file: figmaFileKey
        },
        keywords: keywords,
        width: c.absoluteBoundingBox.width,
        height: c.absoluteBoundingBox.height,
      }

      return data
    }, {})
  })
  .then(data => {

    const icons = Object.values(data)
    // Make a query string with all the component ids
    let componentIds = icons.map(c => c.figma.id ).join(",")

    // Request all the image export URLs from figma
    return getFigmaImageUrls(componentIds)
      .then(images => {

        let svgo = new SVGO(Object.assign(
          {},
          yaml.safeLoad(fs.readFileSync(resolve(__dirname,'../.svgo.yml'), 'utf8'))
        ))

        spinner.info("Downloading SVG files from aws")
        spinner.start("")

        // For each octicon
        return Promise.all(icons.map(icon => {
          return got.get(images[icon.figma.id], {
              headers: {
                "Content-Type": "images/svg+xml"
              }
            })
            .on('downloadProgress', () => {
              spinner.text = `${progress(dCount, oCount)} Downloading ${icon.name} icon`
            })
            .then(response => {
              const svg = response.body
              dCount++
              return svgo.optimize(svg, {})
                .then(optimized => {
                  icon.path = optimized.data.slice(optimized.data.indexOf('>') + 1).slice(0, -6)
                  return fs.ensureDir(join(outputDir, 'svg'))
                    .then(() => fs.writeFileSync(resolve(outputDir, `svg/${icon.name}.svg`), optimized.data, "utf8"))
                })
                .catch((err) => {
                  console.error("Something went wrong optimizing the svg data!", err)
                  process.exit(1)
                })
            })
        }))
    })
    .then(() => {
      spinner.stopAndPersist({
        text: `${progress(dCount, oCount)} ${Object.keys(data).length} icons downloaded`
      })
      spinner.info("Writing data out to lib/build/data.json")
      fs.writeFileSync(resolve(outputDir, 'data.json'), JSON.stringify(icons), "utf8")
      console.warn("\nAll done! Icons successfully exported.")
    })

  })
  .catch(err => {
    console.error(err)
    process.exitCode = 1
  })

function getFigmaComponents() {
  spinner.info("Getting components from the figma file")
  spinner.start(`Contacting ${FIGMA_DOMAIN}`)
  return got.get(`${FIGMA_DOMAIN}/v1/files/${figmaFileKey}`, {
      headers: {
        "Content-Type": "application/json",
        "x-figma-token": FIGMA_TOKEN
      },
      json: true
    })
    .then(response => {
      spinner.start('Processing response')
      const {document, components} = response.body
      const canvas = getCanvas(document, 'Octicons')
      return canvas.children
        .filter(child => {
          return child.type == "COMPONENT"
        })
        .map(child => {
          child.description = components[child.id].description
          return child
        })
    })
    .then(components => {
      oCount = components.length
      spinner.succeed(`${oCount} icons found in the figma file`)
      return components
    })
    .catch(err => {
      spinner.fail("Error: Getting getting octicons from figma file")
      throw err
    })
}

function getFigmaImageUrls(componentIds) {
  spinner.info("Exporting figma components as SVG")
  return got.get(`${FIGMA_DOMAIN}/v1/images/${figmaFileKey}`, {
      query: {
        ids: componentIds,
        format: "svg"
      },
      headers: {
        "Content-Type": "application/json",
        "x-figma-token": FIGMA_TOKEN
      },
      json: true
    })
    .then(response => {
      if (response.body.err) {
        throw response.body.err
      } else {
        spinner.succeed('Successfully exported components')
        return response.body.images
      }
    })
}

function getCanvas(doc, name) {
  const matched = doc.children
    .filter(child => child.type === 'CANVAS' && child.name === name)
  if (!matched.length) {
    throw new Error(`Unable to find canvas named "${name}"`)
  }
  return matched[0]
}

function getPreviousData() {
  const {figma} = require('../package.json')
  const {name, version} = require('../lib/octicons_node/package.json')
  const url = `https://raw.githubusercontent.com/primer/octicons/v${version}/package.json`
  return got.get(url, {json: true})
    .then(response => response.body)
    .then(pkg => {
      // same file; good to go!
      if (pkg.figma.file === figma.file) {
        const baseURL = `https://unpkg.com/${name}@${version}/build/`
        spinner.info("Getting components from unpkg.com")
        spinner.start('Fetching data.json...')
        return fetchAndWrite(baseURL, 'data.json', outputDir)
          .then(JSON.parse)
          .then(data => {
            fs.writeFileSync(join(outputDir, 'data.json'), JSON.stringify(data), 'utf8')
            const icons = Object.values(data)
            const total = icons.length
            let loaded = 0
            spinner.start('Fetching SVG files...')
            const queue = new PQueue({concurrency: 3})
            for (const icon of icons) {
              queue.add(() => {
                loaded++
                spinner.text = `${progress(loaded, total)} Downloading icon: ${icon.name}`
                const filename = join('svg', `${icon.name}.svg`)
                return fetchAndWrite(baseURL, filename, outputDir)
                  .catch(err => {
                    console.error('shit:', err)
                    process.exit(1)
                  })
              })
            }
            queue.start()
            return queue.onIdle().then(() => icons)
          })
          .then(icons => {
            spinner.info(`Wrote ${icons.length} icons to ${outputDir}/svg`)
            spinner.succeed(`${icons.length} icons fetched from ${name}@${version}`)
          })
      } else {
        console.error(`figma.file mismatch: "${figma.file}" !== "${pkg.figma.file}"`)
        process.exitCode = 1
      }
    })
}

function fetchAndWrite(baseURL, file, dirname) {
  return execa('curl', ['-sL', join(baseURL, file)])
    .then(({stdout}) => {
      fs.writeFileSync(join(dirname, file), stdout, 'utf8')
      return stdout
    })
}
